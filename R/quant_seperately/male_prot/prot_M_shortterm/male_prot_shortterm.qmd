---
title: "male_prot"
format: html
---


# Load dependencies
```{r setup}
#| message: false
#| warning: false

source(here::here("R/library.R"))
source(here::here("R/functions.R"))
source(here::here("R/metadata.R"))
load(here::here("data/prot_male_renamed_shortterm.rda"))
load(here::here("data/prot_male_renamed_shortterm_filt_norm.rda"))
load(here::here("data/prot_male_renamed_shortterm_filt_norm_batchcorr.rda"))
load(here::here("data/metadata_M_shortterm.rda"))
```


# Load raw data 
```{r}
raw_prot_M <- readr::read_tsv(here::here("data-raw/20250908_145554_MMM_prot_male_Report.tsv"))
metadata_M <- metadata %>% filter(sex == "M")

usethis::use_data(raw_prot_M, metadata_M, overwrite = T)
```

## Modify raw data
```{r}
duplicate_genes <- raw_prot_M %>% 
    dplyr::count(PG.Genes) %>% 
    filter(n > 1)

raw_prot_duplicates <- raw_prot_M %>%
  dplyr::filter(
      PG.Genes %in% duplicate_genes$PG.Genes,
      !is.na(PG.Genes)) # remove NA


# fix duplicated genes
raw_prot_M_genefixed <- raw_prot_M %>%
  mutate(
    # The condition checks for all three problems at once
    PG.Genes = if_else(
      is.na(PG.Genes) | PG.Genes == "" | duplicated(PG.Genes) | duplicated(PG.Genes, fromLast = TRUE),
      
      # If TRUE (the gene name is problematic), use the value from Protein_ID
      true = PG.ProteinGroups,
      
      # If FALSE (the gene name is fine), keep the original Gene name
      false = PG.Genes
    )
  )

any(duplicated(raw_prot_M_genefixed$PG.Genes)) # False
any(is.na(raw_prot_M_genefixed$PG.Genes)) # check for NA
any(is.nan(raw_prot_M_genefixed$PG.Genes)) # check for NaN
any(raw_prot_M_genefixed$PG.Genes == "") # check for empty rows


# create quantitative df
prot_M <- raw_prot_M_genefixed %>% 
    dplyr::select(PG.Genes, contains("2024")) %>% 
    column_to_rownames(var = "PG.Genes") %>% 
    dplyr::mutate(across(everything(), as.numeric)) %>% 
    dplyr::mutate(across(everything(), ~ replace(., is.nan(.), NA))) %>%
    dplyr::mutate(across(everything(), log2))

#colnames(prot_M)


prot_M_renamed <- prot_M %>%
  rename_with(~ sub(".*_(S[0-9]+)_.*", "\\1", .)) %>% 
  rename_with(~ gsub("^S", "s", .))

setequal(colnames(prot_M_renamed), metadata_M$sample_id) # regardless of order 
all(colnames(prot_M_renamed) == metadata_M$sample_id)  # checks the order

usethis::use_data(prot_M_renamed, overwrite = TRUE)
```


## Align with metadata
```{r}
print(metadata_M$sample_id)
print(colnames(prot_M_renamed))


setdiff(metadata_M$sample_id, colnames(prot_M_renamed))  # should be character(0)
prot_M_renamed <- prot_M_renamed %>% dplyr::select(dplyr::all_of(metadata_M$sample_id))

all(colnames(prot_M_renamed) == metadata_M$sample_id)  # checks the order

# Compare metadata sample IDs with data column names
comparison <- data.frame(
  Metadata = metadata_M$sample_id,
  Data     = colnames(prot_M_renamed)
)
print(comparison)
```



# Missing values
```{r}
# valid values
valid_counts <- colSums(!is.na(prot_M_renamed))
count_data <- data.frame(column = names(valid_counts), count = valid_counts)
count_data$column <- factor(count_data$column, levels = count_data$column)


mean_value <- mean(count_data$count)
y_max <- max(count_data$count)
y_buffer <- max(20, 0.05 * y_max)
y_limit <- y_max + y_buffer

vv_male <- ggplot(count_data, aes(x = column, y = count)) +
  geom_bar(stat = "identity", fill = "lightblue") +
  geom_hline(yintercept = mean_value, color = "red", linetype = "dashed", size = 1, alpha = 0.3) +
  annotate("text", x = length(count_data$column) / 2 + 0.5, 
           y = mean_value + y_buffer / 2,
           label = paste0("Mean = ", round(mean_value, 0)),
           color = "red", size = 5, fontface = "bold") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1)), limits = c(0, y_limit)) +
  labs(
    title = "Proteins per sample, male all (n=116)",
    x = "",
    y = "Valid Values") +
  theme_minimal(base_size = 14) +
  theme(plot.title   = element_text(face = "bold", hjust = 0.5, size = 13),
        axis.text.x  = element_text(angle = 45, hjust = 1, vjust = 1, size = 8, color = "black"),
        axis.text.y  = element_text(size = 12, color = "black"),
        axis.title.x = element_text(size = 14, color = "black"),
        axis.title.y = element_text(size = 14, color = "black"),
        panel.grid.major.x = element_blank())


print(vv_male)
ggsave(file.path("doc", "vv_male_prot.png"), plot = vv_male, width = 14, height = 3, dpi = 300, bg = "white")


dim(prot_M_renamed) # 7565 - 116 samples
sum(is.na(prot_M_renamed)) # 32852

# 1. Prepare the binary NA matrix (0 = present, 1 = missing)
missing_matrix <- as.matrix(is.na(prot_M_renamed)) * 1

annotation_col <- metadata_M %>%
  dplyr::select(sample_id, diet, strain, weeks) %>%
  tibble::column_to_rownames(var = "sample_id")

# alignment check
stopifnot(all(colnames(missing_matrix) == rownames(annotation_col))) # will error if not aligned

# --- Step 4: Generate the Final Heatmap ---
na_heatmap_male <- pheatmap(
  missing_matrix,                    # The 0/1 data matrix
  annotation_col = annotation_col,   # The annotation data frame with correct rownames
  cluster_rows = FALSE,              # Don't cluster thousands of genes, it's slow and uninformative
  cluster_cols = TRUE,               # Cluster samples to see which are similar in missingness
  show_rownames = FALSE,             # Don't show the gene names, there are too many
  show_colnames = FALSE,              # Hide sample IDs
  color = c("gray95", "black"),       # Use two distinct colors for Present (0) and Missing (1)
  legend_breaks = c(0, 1),            # Specify breaks for the legend
  legend_labels = c("Present", "Missing"), # Label the legend clearly
  main = "Male, all (n=116)"  # Add a title
)

ggsave(file.path("doc", "na_heatmap_male.png"),plot = na_heatmap_male, width = 7, height = 6, dpi = 300, bg = "white")
```


# Dynamic range
```{r}
# use waq-values (non log2)
prot_M_renamed_nonlog2 <- 2^prot_M_renamed

# add ranking and median values
abundance_data <- prot_M_renamed_nonlog2 %>%
  rownames_to_column("proteins") %>%
  mutate(median = rowMedians(as.matrix(dplyr::select(., -proteins)), na.rm = TRUE)) %>%
  arrange(desc(median)) %>%
  mutate(rank = row_number())

# prep proteins for labeling
N <- 10
top_proteins <- abundance_data$proteins[1:N]
bottom_proteins <- abundance_data$proteins[(nrow(abundance_data)-N+1):nrow(abundance_data)]
custom_proteins <- c("Akt1", "Akt2", "Akt1s1", "Gsk3a", "Gsk3b", "Irs1", "Irs2", "Insr", "Cps1", "Gpt", "Gpt2", "Adh1", "Alb") 

abundance_data <- abundance_data %>%
  mutate(
    Category = case_when(
      proteins %in% custom_proteins  ~ "Custom highlight",
      proteins %in% top_proteins     ~ "Most abundant",
      proteins %in% bottom_proteins  ~ "Least abundant",
      TRUE                           ~ "Other"
    )
  )

highlighted <- abundance_data %>% filter(Category != "Other")



abundance_plot_male <- ggplot(abundance_data, aes(x = rank, y = log10(median))) +
  geom_point(
    aes(color = Category),
    size = 1,
    alpha = 0.7,
    show.legend = FALSE
  ) +
  geom_point(
    data = highlighted,
    aes(x = rank, y = log10(median), color = Category),
    size = 3
  ) +
  geom_label_repel(
    data = highlighted,
    aes(x = rank, y = log10(median), label = proteins, fill = Category),
    color = "black",
    size = 5,
    max.overlaps = 25,
    nudge_y = 0.1,
    box.padding = 0.5,
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "Most abundant"    = "#E69F00",
      "Least abundant"   = "#56B4E9",
      "Custom highlight" = "#D55E00",
      "Other"            = "gray60"
    )
  ) +
  scale_fill_manual(
    values = c(
      "Most abundant"    = "#FFE5B4",
      "Least abundant"   = "#CFE2F3",
      "Custom highlight" = "#F7CAC9"
    )
  ) +
  labs(
    title = "Protein Abundance, male",
    x = "protein abundance rank",
    y = "Median intensity (log10)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "none"
  )

print(abundance_plot_male)
ggsave(file.path("doc", "abundance_plot_male.png"),plot = abundance_plot_male,width = 6,height = 7,dpi = 300,bg = "white")
```

# Cumulative dynamic range
```{r}
abund_df <- prot_M_renamed_nonlog2 %>%
  mutate(median = matrixStats::rowMedians(as.matrix(.), na.rm = TRUE)) %>%
  arrange(desc(median)) %>%
  mutate(
    rank    = row_number(),
    protein = rownames(.),
    prop    = median / sum(median, na.rm = TRUE),
    cumperc = cumsum(prop) * 100
  )

n   <- nrow(abund_df)
top <- min(10, n)
y_top <- abund_df$cumperc[top]
top10_lab <- paste0("Top 10:\n", paste(abund_df$protein[1:top], collapse = "\n"))

# --- Quartiles on the Y axis ---
# ranks at which cumulative % first reaches 25, 50, 75
r25 <- which(abund_df$cumperc >= 25)[1]
r50 <- which(abund_df$cumperc >= 50)[1]
r75 <- which(abund_df$cumperc >= 75)[1]

# counts per quartile
q_counts <- c(
  Q1 = r25,
  Q2 = r50 - r25,
  Q3 = r75 - r50,
  Q4 = n - r75
)

# positions for labels
y_mid   <- c(12.5, 37.5, 62.5, 87.5)
x_right <- n * 0.97

# Plot
abund_df <- abund_df %>%
  mutate(top10_flag = ifelse(rank <= 10, "Top10", "Other"))

cumulative <- ggplot(abund_df, aes(x = rank, y = cumperc)) +
  # quartile bands (background)
  annotate("rect", xmin = 1, xmax = n, ymin = 0,  ymax = 25, fill = "blue", alpha = 0.1) +
  annotate("rect", xmin = 1, xmax = n, ymin = 25, ymax = 50, fill = "red", alpha = 0.1) +
  annotate("rect", xmin = 1, xmax = n, ymin = 50, ymax = 75, fill = "blue", alpha = 0.1) +
  annotate("rect", xmin = 1, xmax = n, ymin = 75, ymax = 100, fill = "red", alpha = 0.1) +
  
  # cumulative curve
  geom_line(size = 1, colour = "#1f4e79") +
  
  # highlight points: red for Top10, black for the rest
  geom_point(aes(color = top10_flag), size = 2) +
  scale_color_manual(values = c("Top10" = "red", "Other" = "black")) +
  
  # quartile count labels
  annotate("text", x = n*0.97, y = 12.5, label = paste0("Q1 ", q_counts[1]), hjust = 1) +
  annotate("text", x = n*0.97, y = 37.5, label = paste0("Q2 ", q_counts[2]), hjust = 1) +
  annotate("text", x = n*0.97, y = 62.5, label = paste0("Q3 ", q_counts[3]), hjust = 1) +
  annotate("text", x = n*0.97, y = 87.5, label = paste0("Q4 ", q_counts[4]), hjust = 1) +
  
  # axes & theme
  scale_y_continuous(limits = c(0, 100), expand = c(0, 0),
                     name = "Cumulative abundance [%]") +
  scale_x_continuous(expand = c(0, 0), name = "Abundance rank") +
  coord_cartesian(xlim = c(0, min(n, 9000)), clip = "off") +
  theme_minimal(base_size = 12) +
  theme(panel.grid = element_blank(),
        plot.margin = margin(10, 30, 10, 10),
        legend.position = "none")

# If you also want the counts printed in the console:
data.frame(
  Quartile = c("Q1 (0–25%)", "Q2 (25–50%)", "Q3 (50–75%)", "Q4 (75–100%)"),
  Proteins = as.integer(q_counts)
)

ggsave(file.path("doc", "cumulative.png"), plot = cumulative, width = 3, height = 4, dpi = 300,bg = "white")
```


# Subgroup data into shortterm and longterm
```{r}
metadata_M_shortterm <- metadata %>% filter(sex == "M", weeks == "12")
metadata_M_longterm <- metadata %>% filter(sex == "M", diet == "FFMD", weeks %in% c(24, 36, 48))

# create new_sample_id column in each metadata
metadata_M_shortterm <- metadata_M_shortterm %>% mutate(new_sample_id = paste0("S", row_number()))
metadata_M_longterm <- metadata_M_longterm %>% mutate(new_sample_id = paste0("S", row_number()))
# rename with new sample ids
# For shortterm
prot_male_renamed_shortterm <- prot_M_renamed[, metadata_M_shortterm$sample_id]
colnames(prot_male_renamed_shortterm) <- setNames(
  metadata_M_shortterm$new_sample_id,
  metadata_M_shortterm$sample_id
)[colnames(prot_male_renamed_shortterm)]


# For longterm
prot_male_renamed_longterm <- prot_M_renamed[, metadata_M_longterm$sample_id]
colnames(prot_male_renamed_longterm) <- setNames(
  metadata_M_longterm$new_sample_id,
  metadata_M_longterm$sample_id
)[colnames(prot_male_renamed_longterm)]

all(colnames(prot_male_renamed_shortterm) == metadata_M_shortterm$new_sample_id)
all(colnames(prot_male_renamed_longterm) == metadata_M_longterm$new_sample_id)

usethis::use_data(prot_male_renamed_shortterm, overwrite = T)
usethis::use_data(prot_male_renamed_longterm, overwrite = T)
usethis::use_data(raw_prot_M, metadata_M, metadata_M_shortterm, metadata_M_longterm, overwrite = T)
```


# Male-shortterm study
only 12 weeks, diet effect
data is prot_male_renamed_shortterm

## Valid values
```{r}
# valid values
valid_counts <- colSums(!is.na(prot_male_renamed_shortterm))
count_data <- data.frame(column = names(valid_counts), count = valid_counts)
count_data$column <- factor(count_data$column, levels = count_data$column)


mean_value <- mean(count_data$count)
y_max <- max(count_data$count)
y_buffer <- max(20, 0.05 * y_max)
y_limit <- y_max + y_buffer

vv1 <- ggplot(count_data, aes(x = column, y = count)) +
  geom_bar(stat = "identity", fill = "lightblue") +
  geom_hline(yintercept = mean_value, color = "red", linetype = "dashed", size = 1, alpha = 0.3) +
  annotate("text", x = length(count_data$column) / 2 + 0.5, 
           y = mean_value + y_buffer / 2,
           label = paste0("Mean = ", round(mean_value, 0)),
           color = "red", size = 5, fontface = "bold") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1)), limits = c(0, y_limit)) +
  labs(
    title = "Proteins per sample, male-12weeks (n=36)",
    x = "",
    y = "Valid Values") +
  theme_minimal(base_size = 14) +
  theme(plot.title   = element_text(face = "bold", hjust = 0.5, size = 13),
        axis.text.x  = element_text(angle = 45, hjust = 1, vjust = 1, size = 8, color = "black"),
        axis.text.y  = element_text(size = 12, color = "black"),
        axis.title.x = element_text(size = 14, color = "black"),
        axis.title.y = element_text(size = 14, color = "black"),
        panel.grid.major.x = element_blank())


print(vv1)
ggsave(file.path("doc", "vv1_male_prot_shortterm.png"), plot = vv1, width = 7, height = 3, dpi = 300, bg = "white")
```


## Distribution
```{r}
# Now, create the plot and save it
png(filename = "doc/boxplot_prot_male_shortterm.png",
    width    = 10,
    height   = 6,
    units    = "in",
    res      = 300)

# 1. Draw the boxplot as before
boxplot(prot_male_renamed_shortterm, 
        main = "Male 12weeks (n=36)",
        ylab = "Log2 Intensity", # Adding a y-axis label is good practice
        col = "lightblue")      # Adding some color can help


dev.off()

##########
# Convert data to long format
df_long <- tidyr::pivot_longer(prot_male_renamed_shortterm, 
                               cols = everything(), 
                               names_to = "sample_id", 
                               values_to = "intensity")


density_plot_global <- ggplot(df_long, aes(x = intensity, color = sample_id)) +
  geom_density() +
  labs(title = "Density Distribution, male_12w (global)", x = "Intensity", y = "Density") +
  theme_minimal(base_size = 14) +
  theme(
      plot.title = element_text(hjust = 0.5, face = "bold", size = 13),
      legend.position = "none")

density_plot_global
ggsave(file.path("doc", "densityplot_M_prot_shortterm.png"), plot = density_plot_global, width = 7, height = 4, dpi = 300, bg = "white")
```





# PCA1 - checking outliers
```{r}
n_original <- nrow(prot_male_renamed_shortterm) # 7565
df_nona <- na.omit(prot_male_renamed_shortterm) # 6287
n_nona <- nrow(df_nona)

# transpose data 
pca_nona <- prcomp(t(df_nona), scale = TRUE)
# quick scatter plot
factoextra::fviz_pca_ind(pca_nona) 
plot(pca_nona$x[,1], pca_nona$x[,2])

# Eigenvalues (variance explained by each PC)
pca_var <- pca_nona$sdev^2 
pca_var_perc <- round(pca_var/sum(pca_var)*100, digits = 1)
fviz_eig(pca_nona, addlabels = TRUE)  # scree plot 

pca_results <- as.data.frame(pca_nona$x) %>%
  tibble::rownames_to_column("new_sample_id")  # keep sample IDs

pca_data <- pca_results %>%
  dplyr::select(new_sample_id, PC1, PC2, PC3, PC4) %>% 
  dplyr::inner_join(metadata_M_shortterm, by = "new_sample_id") %>%
  dplyr::mutate(
    hover_text = paste0(
      "new_sample_id: ", new_sample_id,
      "<br>Sample: ", sample_id,
      "<br>Diet: ", diet,
      "<br>Strain: ", strain
    )
  )

# Should be all TRUE / empty set
all(pca_results$sample_id %in% metadata_M_shortterm$new_sample_id)


 
pca_day <- plot_pca(
    data = pca_data,
    color_var = "prep_day_batch",
    shape_var = "diet",
    palette_name = "Set1",
    plot_title = "global, M, 12week (n=36)",
    ellipse = FALSE
)


pca_beatbox <- plot_pca(
    data = pca_data,
    color_var = "prep_day_batch",
    shape_var = "beatbox_batch",
    shape_vals = c(16,17,15,3,7,8,1,2,0,4,5,6),
    palette_name = "Set1",
    plot_title = "global, M, 12week (n=36)",
    ellipse = FALSE
)

plotly::ggplotly(pca_beatbox)
plotly::ggplotly(pca_day)

ggsave(file.path("doc", "pca_day_beforenorm_Mshort.png"), plot = pca_day, width = 7, height = 5, dpi = 300, bg = "white")
ggsave(file.path("doc", "pca_beatbox_beforenorm_Mshort.png"), plot = pca_beatbox, width = 7, height = 5, dpi = 300, bg = "white")
```

# Filter
```{r}
#Filter on total matrix
prot_male_renamed_shortterm_filt100 <- PhosR::selectOverallPercent(prot_male_renamed_shortterm, 1) # 6287
prot_male_renamed_shortterm_filt70 <- PhosR::selectOverallPercent(prot_male_renamed_shortterm, 0.7) # 7331
prot_male_renamed_shortterm_filt50 <- PhosR::selectOverallPercent(prot_male_renamed_shortterm, 0.5) # 7148

prot_male_renamed_shortterm_filt <- prot_male_renamed_shortterm_filt70
usethis::use_data(prot_male_renamed_shortterm_filt, overwrite = T)
```

## Filter 2: groupwise
```{r}
min_completeness_per_group <- 0.7
groups <- paste(metadata_M_shortterm$diet, metadata_M_shortterm$strain, sep = "_")
unique_groups <- unique(groups)

# Print the groups to verify
print("Experimental groups identified:")
print(table(groups))


proteins_to_keep <- apply(prot_male_renamed_shortterm, 1, function(protein_row) {
  completeness_in_each_group <- sapply(unique_groups, function(group_level) {
    cols_in_group <- which(groups == group_level)
    protein_in_group <- protein_row[cols_in_group]
    completeness <- sum(!is.na(protein_in_group)) / length(protein_in_group)
    
    return(completeness)
  })
  
  # The final decision for this protein: keep it if ANY group met the threshold
  return(any(completeness_in_each_group >= min_completeness_per_group))
})



prot_male_renamed_shortterm_filt_groupwise70 <- prot_male_renamed_shortterm[proteins_to_keep, ]

min_completeness_per_group <- 0.7

# 1. DEFINE THE GROUPS
# We will use the main 'diet' factor for this example.
# If you have more complex groups (e.g., diet_strain), use that 'groups' vector.
groups <- metadata_M_shortterm$diet
unique_groups <- unique(groups)

# 2. THE CORE LOGIC: Find proteins that pass the threshold in ALL groups
proteins_to_keep_strict <- apply(prot_male_renamed_shortterm, 1, function(protein_row) {
    
    # For the current protein, check its completeness in each group
    completeness_in_each_group <- sapply(unique_groups, function(group_level) {
        # Get the sample columns that belong to the current group
        cols_in_group <- which(groups == group_level)
        
        # Get the data for this protein just for those samples
        protein_in_group <- protein_row[cols_in_group]
        
        # Calculate the percentage of non-NA values
        completeness <- sum(!is.na(protein_in_group)) / length(protein_in_group)
        return(completeness)
    })
    
    # THE KEY CHANGE: Keep it only if ALL groups meet the threshold
    return(all(completeness_in_each_group >= min_completeness_per_group))
})

# 3. APPLY THE STRICT FILTER
prot_male_renamed_shortterm_filt_strict70 <- prot_male_renamed_shortterm[proteins_to_keep_strict, ]

# 4. VERIFY AND COMPARE THE RESULT
cat("Original dimensions:", dim(prot_male_renamed_shortterm), "\n")
cat("Dimensions after 'at least one group' filtering:", dim(prot_male_renamed_shortterm_filt_groupwise70), "\n")
cat("Dimensions after 'IN EVERY GROUP' filtering (strict):", dim(prot_male_renamed_shortterm_filt_strict70), "\n")

num_lost <- nrow(prot_male_renamed_shortterm_filt_groupwise70) - nrow(prot_male_renamed_shortterm_filt_strict70)
cat("\nSwitching to the strict filter removed an additional", num_lost, "proteins.\n")
cat("These are the proteins present in one group but not consistently in the other.\n")
```



## Valid values2
```{r}
# valid values
valid_counts <- colSums(!is.na(prot_male_renamed_shortterm_filt))
count_data <- data.frame(column = names(valid_counts), count = valid_counts)
count_data$column <- factor(count_data$column, levels = count_data$column)


mean_value <- mean(count_data$count)
y_max <- max(count_data$count)
y_buffer <- max(20, 0.05 * y_max)
y_limit <- y_max + y_buffer

vv2 <- ggplot(count_data, aes(x = column, y = count)) +
  geom_bar(stat = "identity", fill = "lightblue") +
  geom_hline(yintercept = mean_value, color = "red", linetype = "dashed", size = 1, alpha = 0.3) +
  annotate("text", x = length(count_data$column) / 2 + 0.5, 
           y = mean_value + y_buffer / 2,
           label = paste0("Mean = ", round(mean_value, 0)),
           color = "red", size = 5, fontface = "bold") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1)), limits = c(0, y_limit)) +
  labs(
    title = "Proteins per sample, male-12weeks (n=36)",
    x = "",
    y = "Valid Values") +
  theme_minimal(base_size = 14) +
  theme(plot.title   = element_text(face = "bold", hjust = 0.5, size = 13),
        axis.text.x  = element_text(angle = 45, hjust = 1, vjust = 1, size = 8, color = "black"),
        axis.text.y  = element_text(size = 12, color = "black"),
        axis.title.x = element_text(size = 14, color = "black"),
        axis.title.y = element_text(size = 14, color = "black"),
        panel.grid.major.x = element_blank())


print(vv2)
ggsave(file.path("doc", "vv2_male_prot_shortterm.png"), plot = vv2, width = 7, height = 3, dpi = 300, bg = "white")
```


# Normalize 
```{r}
# from PhosR package
prot_male_renamed_shortterm_filt_norm <- medianScaling(prot_male_renamed_shortterm_filt[1:ncol(prot_male_renamed_shortterm_filt)], scale = TRUE)
prot_male_renamed_shortterm_filt_norm <- as.data.frame(prot_male_renamed_shortterm_filt_norm)

usethis::use_data(prot_male_renamed_shortterm_filt_norm, overwrite = T)
```


## Distribution 
```{r}
# 1. Draw the boxplot as before
boxplot(prot_male_renamed_shortterm_filt_norm, 
        main = "Male 12weeks (n=36)",
        ylab = "Log2 Intensity", # Adding a y-axis label is good practice
        col = "lightblue")      # Adding some color can help



# Now, create the plot and save it
png(filename = "doc/boxplot_prot_male_renamed_shortterm_filt_norm.png",
    width    = 10,
    height   = 6,
    units    = "in",
    res      = 300)

# 1. Draw the boxplot as before
boxplot(prot_male_renamed_shortterm_filt_norm, 
        main = "Male 12weeks (n=36)",
        ylab = "Log2 Intensity", # Adding a y-axis label is good practice
        col = "lightblue")      # Adding some color can help


dev.off()


####
# Convert data to long format
df_long <- tidyr::pivot_longer(prot_male_renamed_shortterm_filt_norm, 
                               cols = everything(), 
                               names_to = "sample_id", 
                               values_to = "intensity")


density_plot_global <- ggplot(df_long, aes(x = intensity, color = sample_id)) +
  geom_density() +
  labs(title = "Density Distribution, male_12w (global)", x = "Intensity", y = "Density") +
  theme_minimal(base_size = 14) +
  theme(
      plot.title = element_text(hjust = 0.5, face = "bold", size = 13),
      legend.position = "none")

density_plot_global
ggsave(file.path("doc", "densityplot_prot_M_shortterm_norm.png"), plot = density_plot_global, width = 7, height = 4, dpi = 300, bg = "white")
```

# PCA2 
```{r}
n_original <- nrow(prot_male_renamed_shortterm_filt_norm) # 7565
df_nona <- na.omit(prot_male_renamed_shortterm_filt_norm) # 6287
n_nona <- nrow(df_nona)

# transpose data 
pca_nona <- prcomp(t(df_nona), scale = TRUE)
# quick scatter plot
factoextra::fviz_pca_ind(pca_nona) 
plot(pca_nona$x[,1], pca_nona$x[,2])

# Eigenvalues (variance explained by each PC)
pca_var <- pca_nona$sdev^2 
pca_var_perc <- round(pca_var/sum(pca_var)*100, digits = 1)
fviz_eig(pca_nona, addlabels = TRUE)  # scree plot 

pca_results <- as.data.frame(pca_nona$x) %>%
  tibble::rownames_to_column("new_sample_id")  # keep sample IDs

pca_data <- pca_results %>%
  dplyr::select(new_sample_id, PC1, PC2, PC3, PC4) %>% 
  dplyr::inner_join(metadata_M_shortterm, by = "new_sample_id") %>%
  dplyr::mutate(
    hover_text = paste0(
      "new_sample_id: ", new_sample_id,
      "<br>Sample: ", sample_id,
      "<br>Diet: ", diet,
      "<br>Strain: ", strain
    )
  )

# Should be all TRUE / empty set
all(pca_results$sample_id %in% metadata_M_shortterm$new_sample_id)


 
pca_day_norm <- plot_pca(
    data = pca_data,
    color_var = "prep_day_batch",
    shape_var = "diet",
    palette_name = "Set1",
    plot_title = "global, M, 12week (n=36)",
    ellipse = TRUE
)


pca_beatbox_norm <- plot_pca(
    data = pca_data,
    color_var = "prep_day_batch",
    shape_var = "beatbox_batch",
    shape_vals = c(16,17,15,3,7,8,1,2,0,4,5,6),
    palette_name = "Set1",
    plot_title = "global, M, 12week (n=36)",
    ellipse = FALSE
)


 
pca_diet_norm <- plot_pca(
    data = pca_data,
    color_var = "diet",
    shape_var = "strain",
    color_vals = c("LFD" = "#21908CFF", "FFMD" = "#D55E00"),
    plot_title = "global, M, 12week (n=36)",
    ellipse = TRUE
)

pca_strain_norm <- plot_pca(
    data = pca_data,
    color_var = "strain",
    shape_var = "diet",
    color_vals = c("Ntac" = "#AA3377", "J" = "#CCBB44"),
    plot_title = "global, M, 12week (n=36)",
    ellipse = TRUE
)

#####################
pca_strain_norm_pc23 <- ggplot(pca_data, aes(x = PC2, y = PC3, color = strain, shape = diet, text = hover_text)) + # hover text is for plotly (interactive)
  geom_point(size = 3.5, alpha = 0.7) + # size: diameter of each dot, alpha: transparency (0=invisible, 1=opaque)
  stat_ellipse(aes(group = strain, fill = strain), geom = "path", show.legend = FALSE) + # Overlay 95% t-distribution ellipses by diet group
  scale_color_manual(values = c("Ntac" = "#AA3377", "J" = "#CCBB44" )) +
  labs(
    title = "global, M, 12week (n=36)",
    #subtitle = paste("based on", n_nona, "proteins out of", n_original),
    x = paste0("PC2 (", pca_var_perc[2], "%)"),
    y = paste0("PC3 (", pca_var_perc[3], "%)")
  ) +
  theme_bw(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  )

pca_strain_norm_pc13 <- ggplot(pca_data, aes(x = PC1, y = PC3, color = strain, shape = diet, text = hover_text)) + # hover text is for plotly (interactive)
  geom_point(size = 3.5, alpha = 0.7) + # size: diameter of each dot, alpha: transparency (0=invisible, 1=opaque)
  stat_ellipse(aes(group = strain, fill = strain), geom = "path", show.legend = FALSE) + # Overlay 95% t-distribution ellipses by diet group
  scale_color_manual(values = c("Ntac" = "#AA3377", "J" = "#CCBB44" )) +
  labs(
    title = "global, M, 12week (n=36)",
    #subtitle = paste("based on", n_nona, "proteins out of", n_original),
    x = paste0("PC1 (", pca_var_perc[1], "%)"),
    y = paste0("PC3 (", pca_var_perc[3], "%)")
  ) +
  theme_bw(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  )

print(pca_strain_norm_pc23)
print(pca_strain_norm_pc13)
plotly::ggplotly(pca_beatbox)
plotly::ggplotly(pca_day)

ggsave(file.path("doc", "pca_day_norm_Mshort_norm.png"), plot = pca_day_norm, width = 7, height = 5, dpi = 300, bg = "white")
ggsave(file.path("doc", "pca_beatbox_norm_Mshort_norm.png"), plot = pca_beatbox_norm, width = 7, height = 5, dpi = 300, bg = "white")
ggsave(file.path("doc", "pca_diet_norm_Mshort_norm.png"), plot = pca_diet_norm, width = 7, height = 5, dpi = 300, bg = "white")
ggsave(file.path("doc", "pca_strain_norm_Mshort_norm.png"), plot = pca_strain_norm, width = 7, height = 5, dpi = 300, bg = "white")
ggsave(file.path("doc", "pca_strain23_norm_Mshort_norm.png"), plot = pca_strain_norm_pc23, width = 7, height = 5, dpi = 300, bg = "white")
ggsave(file.path("doc", "pca_strain13_norm_Mshort_norm.png"), plot = pca_strain_norm_pc13, width = 7, height = 5, dpi = 300, bg = "white")
```



# Batchcorr
```{r}
setequal(colnames(prot_male_renamed_shortterm_filt_norm), metadata_M_shortterm$new_sample_id) # TRUE
all(colnames(prot_male_renamed_shortterm_filt_norm) == metadata_M_shortterm$new_sample_id)    # TRUE

prot_male_renamed_shortterm_filt_norm_batchcorr <- limma::removeBatchEffect(
  prot_male_renamed_shortterm_filt_norm,
  batch = metadata_M_shortterm$beatbox_batch
)
prot_male_renamed_shortterm_filt_norm_batchcorr <- as.data.frame(prot_male_renamed_shortterm_filt_norm_batchcorr)
usethis::use_data(prot_male_renamed_shortterm_filt_norm_batchcorr, overwrite = TRUE)
```

## PCA3
```{r}
n_original <- nrow(prot_male_renamed_shortterm_filt_norm_batchcorr) # 7565
df_nona <- na.omit(prot_male_renamed_shortterm_filt_norm_batchcorr) # 6287
n_nona <- nrow(df_nona)

# transpose data 
pca_nona <- prcomp(t(df_nona), scale = TRUE)
# quick scatter plot
factoextra::fviz_pca_ind(pca_nona) 
plot(pca_nona$x[,1], pca_nona$x[,2])

# Eigenvalues (variance explained by each PC)
pca_var <- pca_nona$sdev^2 
pca_var_perc <- round(pca_var/sum(pca_var)*100, digits = 1)
fviz_eig(pca_nona, addlabels = TRUE)  # scree plot 

pca_results <- as.data.frame(pca_nona$x) %>%
  tibble::rownames_to_column("new_sample_id")  # keep sample IDs

pca_data <- pca_results %>%
  dplyr::select(new_sample_id, PC1, PC2, PC3, PC4) %>% 
  dplyr::inner_join(metadata_M_shortterm, by = "new_sample_id") %>%
  dplyr::mutate(
    hover_text = paste0(
      "new_sample_id: ", new_sample_id,
      "<br>Sample: ", sample_id,
      "<br>Diet: ", diet,
      "<br>Strain: ", strain
    )
  )

# Should be all TRUE / empty set
all(pca_results$sample_id %in% metadata_M_shortterm$new_sample_id)


 
pca_day_batchcorr <- plot_pca(
    data = pca_data,
    color_var = "prep_day_batch",
    shape_var = "diet",
    palette_name = "Set1",
    plot_title = "global, M, 12week (n=36)",
    ellipse = TRUE
)


pca_beatbox_batchcorr <- plot_pca(
    data = pca_data,
    color_var = "prep_day_batch",
    shape_var = "beatbox_batch",
    shape_vals = c(16,17,15,3,7,8,1,2,0,4,5,6),
    palette_name = "Set1",
    plot_title = "global, M, 12week (n=36)",
    ellipse = FALSE
)


 
pca_diet_batchcorr <- plot_pca(
    data = pca_data,
    color_var = "diet",
    shape_var = "strain",
    color_vals = c("LFD" = "#21908CFF", "FFMD" = "#D55E00"),
    plot_title = "global, M, 12week (n=36)",
    ellipse = TRUE
)

pca_strain_batchcorr <- plot_pca(
    data = pca_data,
    color_var = "strain",
    shape_var = "diet",
    color_vals = c("Ntac" = "#AA3377", "J" = "#CCBB44"),
    plot_title = "global, M, 12week (n=36)",
    ellipse = TRUE
)

#####################
pca_strain_batchcorr_pc23 <- ggplot(pca_data, aes(x = PC2, y = PC3, color = strain, shape = diet, text = hover_text)) + # hover text is for plotly (interactive)
  geom_point(size = 3.5, alpha = 0.7) + # size: diameter of each dot, alpha: transparency (0=invisible, 1=opaque)
  stat_ellipse(aes(group = strain, fill = strain), geom = "path", show.legend = FALSE) + # Overlay 95% t-distribution ellipses by diet group
  scale_color_manual(values = c("Ntac" = "#AA3377", "J" = "#CCBB44" )) +
  labs(
    title = "global, M, 12week (n=36)",
    #subtitle = paste("based on", n_nona, "proteins out of", n_original),
    x = paste0("PC2 (", pca_var_perc[2], "%)"),
    y = paste0("PC3 (", pca_var_perc[3], "%)")
  ) +
  theme_bw(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  )

pca_strain_batchcorr_pc13 <- ggplot(pca_data, aes(x = PC1, y = PC3, color = strain, shape = diet, text = hover_text)) + # hover text is for plotly (interactive)
  geom_point(size = 3.5, alpha = 0.7) + # size: diameter of each dot, alpha: transparency (0=invisible, 1=opaque)
  stat_ellipse(aes(group = strain, fill = strain), geom = "path", show.legend = FALSE) + # Overlay 95% t-distribution ellipses by diet group
  scale_color_manual(values = c("Ntac" = "#AA3377", "J" = "#CCBB44" )) +
  labs(
    title = "global, M, 12week (n=36)",
    #subtitle = paste("based on", n_nona, "proteins out of", n_original),
    x = paste0("PC1 (", pca_var_perc[1], "%)"),
    y = paste0("PC3 (", pca_var_perc[3], "%)")
  ) +
  theme_bw(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  )

print(pca_strain_batchcorr_pc23)
print(pca_strain_batchcorr_pc13)

ggsave(file.path("doc", "pca_day_batchcorr_Mshort_norm.png"), plot = pca_day_batchcorr, width = 7, height = 5, dpi = 300, bg = "white")
ggsave(file.path("doc", "pca_beatbox_batchcorr_Mshort_norm.png"), plot = pca_beatbox_batchcorr, width = 7, height = 5, dpi = 300, bg = "white")
ggsave(file.path("doc", "pca_diet_batchcorr_Mshort_norm.png"), plot = pca_diet_batchcorr, width = 7, height = 5, dpi = 300, bg = "white")
ggsave(file.path("doc", "pca_strain_batchcorr_Mshort_norm.png"), plot = pca_strain_batchcorr, width = 7, height = 5, dpi = 300, bg = "white")
ggsave(file.path("doc", "pca_strain23_batchcorr_Mshort_norm.png"), plot = pca_strain_batchcorr_pc23, width = 7, height = 5, dpi = 300, bg = "white")
ggsave(file.path("doc", "pca_strain13_batchcorr_Mshort_norm.png"), plot = pca_strain_batchcorr_pc13, width = 7, height = 5, dpi = 300, bg = "white")
```

# Limma: batchcorr data
```{r}
metadata_M_shortterm <- metadata_M_shortterm %>%
  dplyr::mutate(
    diet   = factor(diet, levels = c("LFD", "FFMD")),
    strain = factor(strain, levels = c("J", "Ntac"))
  )

levels(metadata_M_shortterm$diet)
levels(metadata_M_shortterm$strain)

table(metadata_M_shortterm$diet)   # LFD-12, FFMD-24
table(metadata_M_shortterm$strain) # J-18, Ntac-18



# create design matrix
design_matrix_batchcorr <- model.matrix(~ diet + strain, data = metadata_M_shortterm)

colnames(design_matrix_batchcorr)
fit_batchcorr  <- limma::lmFit(prot_male_renamed_shortterm_filt_norm_batchcorr, design_matrix_batchcorr)
fit2_batchcorr <- limma::eBayes(fit_batchcorr)

# use get_limma_results function
limma_results_M_shortterm_diet_batchcorr   <- get_limma_results(fit2_batchcorr, "dietFFMD",   "M12: Diet") # Total: 901 - UP: 622 | DOWN: 279
limma_results_M_shortterm_strain_batchcorr <- get_limma_results(fit2_batchcorr, "strainNtac", "M12: Strain") # Total 414 - UP: 229 | DOWN: 185

# Diet histogram
hist(limma_results_M_shortterm_diet_batchcorr$top_table$P.Value,   main = "M12: Diet main effect (batchcorr)",   xlab = "P-value", col = "darkslategray4", breaks = 30)
hist(limma_results_M_shortterm_strain_batchcorr$top_table$P.Value, main = "M12: Strain main effect (batchcorr)", xlab = "P-value", col = "darkslategray4", breaks = 30)

png(file.path("doc", "M12_main_diet_hist_batchcorr.png"), width = 5, height = 4, units = "in", res = 300, bg = "white")
hist(limma_results_M_shortterm_diet_batchcorr$top_table$P.Value, main = "M12: Diet main effect (batchcorr)", xlab = "P-value", col = "darkslategray4", breaks = 30)
dev.off()

png(file.path("doc", "M12_main_strain_hist_batchcorr.png"), width = 5, height = 4, units = "in", res = 300, bg = "white")
hist(limma_results_M_shortterm_strain_batchcorr$top_table$P.Value, main = "M12: Strain main effect (batchcorr)", xlab = "P-value", col = "darkslategray4", breaks = 30)
dev.off()
```

# Limma: non-batchcorr data
Add batch variable directly in the design matrix. 
```{r}
metadata_M_shortterm <- metadata_M_shortterm %>%
  dplyr::mutate(
    diet   = factor(diet, levels = c("LFD", "FFMD")),
    strain = factor(strain, levels = c("J", "Ntac"))
  )

levels(metadata_M_shortterm$diet)
levels(metadata_M_shortterm$strain)

table(metadata_M_shortterm$diet)   # LFD-12, FFMD-24
table(metadata_M_shortterm$strain) # J-18, Ntac-18
# create design matrix
design_matrix <- model.matrix(~ diet + strain + beatbox_batch, data = metadata_M_shortterm)

colnames(design_matrix)
fit  <- limma::lmFit(prot_male_renamed_shortterm_filt_norm, design_matrix)
fit2 <- limma::eBayes(fit)

# use get_limma_results function
limma_results_M_shortterm_diet   <- get_limma_results(fit2, "dietFFMD",   "M12: Diet") # Total: 1847 - UP: 1156 | DOWN: 691
limma_results_M_shortterm_strain <- get_limma_results(fit2, "strainNtac", "M12: Strain") # Total 357 - UP: 186 | DOWN: 171

# Diet histogram
hist(limma_results_M_shortterm_diet$top_table$P.Value,   main = "M12: Diet main effect",   xlab = "P-value", col = "darkslategray4", breaks = 30)
hist(limma_results_M_shortterm_strain$top_table$P.Value, main = "M12: Strain main effect", xlab = "P-value", col = "darkslategray4", breaks = 30)

png(file.path("doc", "M12_main_diet_hist.png"), width = 5, height = 4, units = "in", res = 300, bg = "white")
hist(limma_results_M_shortterm_diet$top_table$P.Value, main = "M12: Diet main effect", xlab = "P-value", col = "darkslategray4", breaks = 30)
dev.off()

png(file.path("doc", "M12_main_strain_hist.png"), width = 5, height = 4, units = "in", res = 300, bg = "white")
hist(limma_results_M_shortterm_strain$top_table$P.Value, main = "M12: Strain main effect", xlab = "P-value", col = "darkslategray4", breaks = 30)
dev.off()


# For the Diet contrast
write.csv(
  limma_results_M_shortterm_diet$top_table,
  file = "doc/results_diet_M12.csv",
  row.names = TRUE # Keep the protein names
)

# For the Strain contrast
write.csv(
  limma_results_M_shortterm_strain$top_table,
  file = "doc/results_strain_M12.csv",
  row.names = TRUE # Keep the protein names
)

hits_M_prot_diet <- limma_results_M_shortterm_diet$sig
hits_M_prot_strain <- limma_results_M_shortterm_strain$sig
```


## Overlap 
```{r}
method1_batchcorr <- limma_results_M_shortterm_diet_batchcorr$sig$Protein
method2 <- limma_results_M_shortterm_diet$sig$Protein
common_proteins <- intersect(method1_batchcorr, method2)

unique_to_method2 <- setdiff(method2, method1_batchcorr)
unique_to_method1 <- setdiff(method1_batchcorr, method2)

protein_sets <- list(
    batchcorr_proteins = method1_batchcorr,
    nonbatchcorr_proteins = method2
)

fit <- euler(protein_sets)

euler_plot <- plot(
  fit,
  fills = list(fill = c("#91bfdb", "#f1a340"), alpha = 0.7), # Custom colors with transparency
  labels = list(col = "black", fontface = "bold", cex = 1.2), # Labels for set names
  quantities = list(col = "black", fontface = "bold", cex = 1.2), # Numbers inside the circles
  main = "Diet hits, M12" 
)

ggsave(file.path("doc", "euler_plot_diethits.png"), plot = euler_plot, width = 7, height = 5, dpi = 300, bg = "white")


###
method1_batchcorr <- limma_results_M_shortterm_strain_batchcorr$sig$Protein
method2 <- limma_results_M_shortterm_strain$sig$Protein
common_proteins <- intersect(method1_batchcorr, method2)

unique_to_method2 <- setdiff(method2, method1_batchcorr)
unique_to_method1 <- setdiff(method1_batchcorr, method2)

protein_sets <- list(
    batchcorr_proteins = method1_batchcorr,
    nonbatchcorr_proteins = method2
)

fit <- euler(protein_sets)

euler_plot <- plot(
  fit,
  fills = list(fill = c("#91bfdb", "#f1a340"), alpha = 0.7), # Custom colors with transparency
  labels = list(col = "black", fontface = "bold", cex = 1.2), # Labels for set names
  quantities = list(col = "black", fontface = "bold", cex = 1.2), # Numbers inside the circles
  main = "Strain hits, M12" 
)

ggsave(file.path("doc", "euler_plot_strainhits.png"), plot = euler_plot, width = 7, height = 5, dpi = 300, bg = "white")
```


## Check for individual protein
Uneven Medians: In the first plot, you likely saw that the median expression level (the thick horizontal line in the middle of each box) was at different heights for different batches. This indicates a batch effect. A technical, non-biological artifact of the sample processing was making all the measurements in one batch artificially inflated or deflated compared to another. This is unwanted noise that can hide the real biological signals you are looking for (like the effect of diet).

Aligned Medians: In the second plot, you should now see that the medians for all the different batch groups (g1, g2, g3, etc.) are roughly aligned at the same horizontal level.
The removeBatchEffect function doesn't just randomly shift data. Its goal is to make all the batches comparable by adjusting them to a common, global average expression level for that specific protein.

Think of the "Before" plot as having medians scattered all over the y-axis. The batch correction process effectively "squeezes" them from the top and bottom, forcing them to align horizontally in the "After" plot.

```{r}
# --- Step 1: Find a protein that is highly variable (no changes here) ---
row_variances <- apply(prot_male_renamed_shortterm_filt_norm, 1, var, na.rm = TRUE)
protein_to_plot <- names(which.max(row_variances))

# --- Step 2: Prepare data for plotting (no changes here) ---
plot_df <- tibble(
    new_sample_id = colnames(prot_male_renamed_shortterm_filt_norm),
    before_corr = as.numeric(prot_male_renamed_shortterm_filt_norm[protein_to_plot, ]),
    after_corr = as.numeric(prot_male_renamed_shortterm_filt_norm_batchcorr[protein_to_plot, ])
  ) %>%
  # Join with metadata to get batch and diet information
  left_join(metadata_M_shortterm, by = "new_sample_id") %>%
  # Pivot to a long format suitable for ggplot
  pivot_longer(
    cols = c("before_corr", "after_corr"),
    names_to = "correction_status",
    values_to = "expression"
  )

# --- Step 3: Create the boxplots WITH a visible legend ---

# Plot for "Before Correction"
plot_box_before <- ggplot(plot_df %>% filter(correction_status == "before_corr"), 
                          aes(x = beatbox_batch, y = expression, fill = beatbox_batch)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  ggtitle(paste("Before Correction:", protein_to_plot)) +
  theme_bw() +
  labs(x = "Beatbox Batch", y = "Normalized Expression", fill = "Beatbox Batch") + # <- Added legend title
  theme(legend.position = "none")

# Plot for "After Correction"
plot_box_after <- ggplot(plot_df %>% filter(correction_status == "after_corr"), 
                         aes(x = beatbox_batch, y = expression, fill = beatbox_batch)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  ggtitle(paste("After Correction:", protein_to_plot)) +
  theme_bw() +
  labs(x = "Beatbox Batch", y = "Normalized Expression", fill = "Beatbox Batch")+
  theme(legend.position = "none")

# --- Step 4: Show plots side-by-side ---
print(plot_box_before | plot_box_after)

```

# MA plot (Mean-difference plot)
```{r}
# Generate the MA plot for the 'dietFFMD' comparison
# fit2 is your eBayes-moderated fit object
plotMD(fit2, coef = "dietFFMD", status = decideTests(fit2), main = "M12: Diet (FFMD vs LFD)")

# Add a horizontal line at y=0 for reference
abline(h = 0, col = "grey")
```
# Volcano

A statistical test like the one used in limma or edgeR doesn't just look at the average difference between groups; it looks at that difference relative to the variability within the groups.
You will get a highly significant result (a tiny p-value) for a protein with a small fold change if:
Its expression is extremely consistent among all replicates within a group 
The model becomes extremely confident that the small shift between the groups is not random noise, but a real, consistent effect.
```{r}
# 1. Extract the main results data frame from your limma results list
# This is the data frame your function expects as its 'df' input.
volcano_data_diet <- limma_results_M_shortterm_diet$top_table

# 2. Call your custom function with this data frame
# The rownames are already converted to a column named "Protein" by your get_limma_results function, 
# but your volcano function renames it to "Site", which is fine.
p_diet <- create_volcano_plot(
  df = volcano_data_diet,
  title = "M12: Main Diet effect (FFMD vs LFD)",
  top_n = 15 # Let's label the top 15 up/down proteins
)

# 3. Display the plot
print(p_diet)
ggsave(filename = file.path("doc", "volcano_M_shortterm_diet.png"),plot = p_diet, width = 7, height = 6, dpi = 300, bg= "white")

# You can do the same for your strain results
volcano_data_strain <- limma_results_M_shortterm_strain$top_table
p_strain <- create_volcano_plot(
  df = volcano_data_strain,
  title = "M12: Main Strain effect (Ntac vs J)",
  top_n = 15
)
print(p_strain)
ggsave(filename = file.path("doc", "volcano_M_shortterm_strain.png"),plot = p_strain, width = 7, height = 6, dpi = 300, bg= "white")


################################# volcano with FC thresholds
volcano_data_diet <- limma_results_M_shortterm_diet$top_table
```


# heatmap
```{r}
# First, get the list of top protein names
top_proteins_diet <- topTable(fit2, coef = "dietFFMD", number = 50) # Get top 50 proteins

# Extract the batch-corrected expression data for these top proteins
top_protein_data <- prot_male_renamed_shortterm_filt_norm_batchcorr[rownames(top_proteins_diet), ]



# Create an annotation data frame for the columns
annotation_col <- data.frame(
  Diet = metadata_M_shortterm$diet,
  Strain = metadata_M_shortterm$strain
)
rownames(annotation_col) <- colnames(top_protein_data)

pheatmap(top_protein_data,
         main = "Top 50 DE Proteins for Diet",
         annotation_col = annotation_col,
         scale = "row", # Scale expression values per protein
         show_rownames = FALSE, # Can be TRUE if you have few proteins
         show_colnames = FALSE)
```

```{r}
limma_toptable_diet <- limma_results_M_shortterm_diet$top_table %>% 
    column_to_rownames("Protein")

# 1. Select your top significant protein from the diet results
top_protein_name <- rownames(limma_toptable_diet)[3]
top_protein_fdr <- format(limma_toptable_diet[top_protein_name, "adj.P.Val"], scientific = TRUE, digits = 3)

# 2. Create a data frame for this single protein
plot_df <- data.frame(
  Expression = as.numeric(prot_male_renamed_shortterm_filt_norm[top_protein_name, ]),
  Diet = metadata_M_shortterm$diet,
  Strain = metadata_M_shortterm$strain,
  Batch = metadata_M_shortterm$beatbox_batch
)

# 3. Create the boxplot
ggplot(plot_df, aes(x = Diet, y = Expression, fill = Diet)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  facet_wrap(~Strain) + # See if the effect is consistent across strains
  theme_bw(base_size = 14) +
  labs(
    title = paste("Expression of Protein:", top_protein_name),
    subtitle = paste("FDR (adjusted p-value) =", top_protein_fdr),
    y = "Normalized Abundance (log2 scale)",
    x = "Diet"
  ) +
  scale_fill_manual(values = c("LFD" = "blue", "FFMD" = "red"))

```



```{r}
limma_toptable_diet_batchcorr <- limma_results_M_shortterm_diet_batchcorr$top_table %>% 
    column_to_rownames("Protein")

# 1. Select your top significant protein from the diet results
top_protein_name <- rownames(limma_toptable_diet)[3]
top_protein_fdr <- format(limma_toptable_diet[top_protein_name, "adj.P.Val"], scientific = TRUE, digits = 3)

# 2. Create a data frame for this single protein
plot_df <- data.frame(
  Expression = as.numeric(prot_male_renamed_shortterm_filt_norm[top_protein_name, ]),
  Diet = metadata_M_shortterm$diet,
  Strain = metadata_M_shortterm$strain,
  Batch = metadata_M_shortterm$beatbox_batch
)

# 3. Create the boxplot
ggplot(plot_df, aes(x = Diet, y = Expression, fill = Diet)) +
   geom_jitter(width = 0.2, alpha = 0.7) +
  geom_boxplot(outlier.shape = NA) +
  facet_wrap(~Strain) + # See if the effect is consistent across strains
  theme_bw(base_size = 14) +
  labs(
    title = paste("Expression of Protein:", top_protein_name),
    subtitle = paste("FDR (adjusted p-value) =", top_protein_fdr),
    y = "Normalized Abundance (log2 scale)",
    x = "Diet"
  ) +
  scale_fill_manual(values = c("LFD" = "blue", "FFMD" = "red"))

```


# GSEA
```{r}
gsea_gene_list <- limma_results_M_shortterm_diet$top_table %>% 
  filter(!is.na(logFC)) %>%                     # remove rows where logFC is NA
  group_by(Protein) %>% 
  summarise(logFC = max(logFC), .groups = "drop") %>% # compute max logFC per protein
  arrange(desc(logFC)) %>% 
  pull(logFC, name = Protein)                  # create named vector



gsea_bp <- gseGO(
    geneList = gsea_gene_list,
    OrgDb = org.Mm.eg.db,
    ont = "BP",
    pvalueCutoff = 0.05,
    keyType = "SYMBOL",
    nPermSimple = 100000,
    eps = 0)

gsea_bp_filtered <- simplify(
  gsea_bp,
  cutoff = 0.7,
  by = "p.adjust",
  select_fun = min
)



dotplot <- function(gsea_results, categories = 10) {
  gsea_name <- deparse(substitute(gsea_results))
  clusterProfiler::dotplot(gsea_results, showCategory = categories, split = ".sign") +
    facet_grid(. ~ .sign) +
    labs(x = expression(GeneRatio)) +
    theme(axis.text.x = element_text(size = 6),
          strip.text = element_text(size = 6),
          axis.text.y = element_text(size = 6),
          text = element_text(size = 6),
          axis.title.x = element_text(size = 6),
          plot.title = element_text(hjust = 0.5),
          plot.margin = unit(c(1, 1, 1, 4), "lines")) + 
    ggtitle(gsea_name) +
    scale_fill_gradient(low = "#009688", high = "#af8dc3") +
    coord_fixed(ratio = 0.17)  +
      scale_size(range = c(1, 6))
}

gsea_bp_dotplot <- dotplot(gsea_bp_filtered)
print(gsea_bp_dotplot)


###### MF 

gsea_mf <- gseGO(
    geneList = gsea_gene_list,
    OrgDb = org.Hs.eg.db,
    ont = "MF",
    pvalueCutoff = 0.05,
    keyType = "SYMBOL",
    nPermSimple = 100000,
    eps = 0)

gsea_mf_filtered <- simplify(
  gsea_mf,
  cutoff = 0.7,
  by = "p.adjust",
  select_fun = min
)

gsea_mf_dotplot <- dotplot(gsea_mf_filtered)
print(gsea_mf_dotplot)

#### CC
gsea_cc <- gseGO(
    geneList = gsea_gene_list,
    OrgDb = org.Hs.eg.db,
    ont = "CC",
    pvalueCutoff = 0.05,
    keyType = "SYMBOL",
    nPermSimple = 100000,
    eps = 0)

gsea_cc_filtered <- simplify(
  gsea_cc,
  cutoff = 0.7,
  by = "p.adjust",
  select_fun = min
)

gsea_cc_dotplot <- dotplot(gsea_cc_filtered)
print(gsea_cc_dotplot)


ggsave(filename = file.path("doc", "gsea_bp_dotplot.png"),plot = gsea_bp_dotplot, width = 8, height = 5, dpi = 300, bg= "white")
ggsave(filename = file.path("doc", "gsea_mf_dotplot.png"),plot = gsea_mf_dotplot, width = 8, height = 5, dpi = 300, bg= "white")
ggsave(filename = file.path("doc", "gsea_cc_dotplot.png"),plot = gsea_cc_dotplot, width = 8, height = 5, dpi = 300, bg= "white")
```

# Limma Contrasts
concistent with prelimiray results - the diet effect is more exaggerated in J mice than in Ntac in the short-term.
```{r}
metadata_M_shortterm$Group <- paste(metadata_M_shortterm$diet, metadata_M_shortterm$strain, sep = "_")

table(metadata_M_shortterm$Group)
metadata_M_shortterm$Group <- factor(metadata_M_shortterm$Group, levels = c("LFD_J", "LFD_Ntac", "FFMD_J", "FFMD_Ntac"))
levels(metadata_M_shortterm$Group)



design_group <- model.matrix(~ 0 + Group + beatbox_batch, data = metadata_M_shortterm)
colnames(design_group)
colnames(design_group)[1:4] <- colnames(design_group)[1:4] |>
  sub("^Group", "", x = _)   


contrast_matrix <- makeContrasts(
  Diet_in_J       = FFMD_J     - LFD_J,
  Diet_in_Ntac    = FFMD_Ntac  - LFD_Ntac,
  Strain_in_LFD   = LFD_Ntac   - LFD_J,
  Strain_in_FFMD  = FFMD_Ntac  - FFMD_J,
  Interaction     = (FFMD_Ntac - LFD_Ntac) - (FFMD_J - LFD_J),
  levels = design_group
)

fit <- lmFit(prot_male_renamed_shortterm_filt_norm, design_group)
fit2 <- contrasts.fit(fit, contrast_matrix)
fit2 <- eBayes(fit2)

get_limma_results_contrast <- function(fit_obj, coef_name, label, alpha = 0.05) {
  top_table <- limma::topTable(
    fit_obj,
    coef          = coef_name,
    adjust.method = "BH",
    sort.by       = "logFC",
    number        = Inf
  ) %>%
    tibble::rownames_to_column("Protein")
  
  sig  <- top_table %>% dplyr::filter(adj.P.Val < alpha) %>% tidyr::drop_na()
  up   <- sig %>% dplyr::filter(logFC > 0)
  down <- sig %>% dplyr::filter(logFC < 0)
  
  # Print summary
  cat("\n----", label, "----\n")
  cat("Total significant:", nrow(sig), "\n")
  cat("Up:", nrow(up), " | Down:", nrow(down), "\n")
  
  # Save histogram if you want
  png(
    file.path("doc", paste0(label, "_hist.png")),
    width  = 5,
    height = 4,
    units  = "in",
    res    = 300,
    bg     = "white"
  )
  hist(
    top_table$P.Value,
    main = paste(label, "P-value histogram"),
    xlab = "P-value",
    col  = "darkslategray4"
  )
  dev.off()
  
  # Return results as list
  return(list(
    top_table = top_table,
    sig       = sig,
    up        = up,
    down      = down
  ))
}



# 2. Apply to All Contrasts in a Loop

# Get the contrast names you defined:
contrast_names <- colnames(contrast_matrix)

# Loop through all contrasts:
results_list <- list()
for (cname in contrast_names) {
  results_list[[cname]] <- get_limma_results_contrast(
    fit2,
    coef_name = cname,
    label     = cname,
    alpha     = 0.05  # or your chosen FDR threshold
  )
}

# results_list will store each contrast’s full results for later inspection.
# Plots and printouts are created for each contrast automatically.
limma_results_M12_contrasts <- results_list

diet_effect_J_table <- limma_results_M12_contrasts$Diet_in_J$top_table
```

